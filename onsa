#!/usr/bin/env python

import os
import sys
import uuid
import socket
import random

from twisted.python import log, usage
from twisted.internet import reactor, defer

from opennsa import setup, nsa
from opennsa.cli import options, parser, commands, logobserver


CLI_DEFAULTS            = '.opennsa-cli'
WSDL_DEFAULT_DIRECTORY  = '/usr/local/share/nsi/wsdl'
REQUESTER_URL_BASE      = 'http://%s:%i/NSI/services/ConnectionService'


@defer.inlineCallbacks
def doMain():
    config = parser.Options()
    try:
        config.parseOptions()
    except usage.UsageError, errortext:
        print '%s: %s' % (sys.argv[0], errortext)
        print '%s: Try --help for usage details.' % (sys.argv[0])
        return

    observer = logobserver.SimpleObserver(sys.stdout)
    log.startLoggingWithObserver(observer.emit)

    if config[options.VERBOSE]:
        observer.debug = True

    # read defaults
    defaults_file = config[options.DEFAULTS_FILE] or os.path.join( os.path.expanduser('~'), CLI_DEFAULTS )
    if os.path.exists(defaults_file):
        defaults = options.readDefaults( open(defaults_file) )
    else:
        defaults = {}

    log.msg('Defaults:', debug=True)
    for k,v in defaults.items():
        log.msg(' %s : %s' % (k,v), debug=True)

    if config.subCommand in ['reserve', 'provision', 'release', 'terminate', 'querysummary', 'querydetails']:

        wsdl_dir        = config[options.WSDL_DIRECTORY]    or defaults.get(options.WSDL_DIRECTORY) or WSDL_DEFAULT_DIRECTORY
        host            = config[options.HOST]              or defaults.get(options.HOST)           or socket.getfqdn()
        port            = config[options.PORT]              or defaults.get(options.PORT)           or 7080
        requester_url   = REQUESTER_URL_BASE % (host, port)

        topology_file   = config.subOptions[options.TOPOLOGY_FILE]  or defaults.get(options.TOPOLOGY_FILE)
        network         = config.subOptions[options.NETWORK]        or defaults.get(options.NETWORK)
        service_url     = config.subOptions[options.SERVICE_URL]    or defaults.get(options.SERVICE_URL)

        requester_nsa   = config.subOptions[options.REQUESTER]      or defaults.get(options.REQUESTER)      or 'OpenNSA-CLI'
        provider_nsa    = config.subOptions[options.PROVIDER]       or defaults.get(options.PROVIDER)

        connection_id   = config.subOptions[options.CONNECTION_ID]  or defaults.get(options.CONNECTION_ID)
        global_id       = config.subOptions[options.GLOBAL_ID]      or defaults.get(options.GLOBAL_ID)

        if topology_file and network:
            client_nsa      = nsa.NetworkServiceAgent(requester_nsa, requester_url)

            from opennsa import topology
            topo = topology.parseGOLETopology( open(topology_file) )
            provider_nsa  = topo.getNetwork(network).nsa

        elif service_url:
            client_nsa      = nsa.NetworkServiceAgent(requester_nsa, requester_url)
            provider_nsa    = nsa.NetworkServiceAgent(provider_nsa, service_url)

        else:
            raise usage.UsageError('Neither topology file+network or service URL defined')

        # setup ssl context
        public_key          = config.subOptions[options.PUBLIC_KEY]         or defaults.get(options.PUBLIC_KEY)
        private_key         = config.subOptions[options.PRIVATE_KEY]        or defaults.get(options.PRIVATE_KEY)
        certificate_dir     = config.subOptions[options.CERTIFICATE_DIR]    or defaults.get(options.CERTIFICATE_DIR)
        skip_cert_verify    = config.subOptions[options.SKIP_CERT_VERIFY]   or defaults.get(options.SKIP_CERT_VERIFY)   or False

        ctx_factory = None
        if public_key or private_key or certificate_dir:

            if public_key and private_key and certificate_dir:
                from opennsa import ctxfactory
                ctx_factory = ctxfactory.ContextFactory(private_key, public_key, certificate_dir, not skip_cert_verify)
            else:
                log.msg('Only partial security configuration given. Cannot create SSL/TLS context.')

        client, factory = setup.createClient(host, port, wsdl_dir, ctx_factory)
        if ctx_factory:
            iport = reactor.listenSSL(port, factory, ctx_factory)
        else:
            iport = reactor.listenTCP(port, factory)

    # commands

    if config.subCommand == 'reserve':

        source_stp = config.subOptions[options.SOURCE_STP]  or defaults.get(options.SOURCE_STP)
        dest_stp   = config.subOptions[options.DEST_STP]    or defaults.get(options.DEST_STP)
        if source_stp is None:
            raise usage.UsageError('Source STP is not defined')
        if dest_stp is None:
            raise usage.UsageError('Dest STP is not defined')

        start_time  = config.subOptions[options.START_TIME] or defaults.get(options.START_TIME)
        end_time    = config.subOptions[options.END_TIME]   or defaults.get(options.END_TIME)
        if start_time is None:
            raise usage.UsageError('Start time is not defined')
        if end_time is None:
            raise usage.UsageError('End time is not defined')

        bandwidth = config.subOptions[options.BANDWIDTH] or defaults.get(options.BANDWIDTH)
        if bandwidth is None:
            raise usage.UsageError('Bandwidth is not defined')

        bandwidth = config.subOptions[options.BANDWIDTH] or defaults.get(options.BANDWIDTH)

        if connection_id is None:
            connection_id = uuid.uuid1()
        if global_id is None:
            global_id = 'conn-%i' % random.randrange(1000,9999)

        yield commands.reserve(client, client_nsa, provider_nsa, source_stp, dest_stp, start_time, end_time, bandwidth, connection_id, global_id)

    elif config.subCommand == 'provision':

        if connection_id is None:
            raise usage.UsageError('Connection ID is not defined')

        yield commands.provision(client, client_nsa, provider_nsa, connection_id)

    elif config.subCommand == 'release':

        if connection_id is None:
            raise usage.UsageError('Connection ID is not defined')

        yield commands.release(client, client_nsa, provider_nsa, connection_id)

    elif config.subCommand == 'terminate':

        if connection_id is None:
            raise usage.UsageError('Connection ID is not defined')

        yield commands.terminate(client, client_nsa, provider_nsa, connection_id)

    elif config.subCommand == 'querysummary':

        connection_ids  = [ connection_id   ] if connection_id  else None
        global_ids      = [ global_id       ] if global_id      else None
        yield commands.querysummary(client, client_nsa, provider_nsa, connection_ids, global_ids)

    elif config.subCommand == 'querydetails':

        connection_ids  = [ connection_id   ] if connection_id  else None
        global_ids      = [ global_id       ] if global_id      else None
        yield commands.querydetails(client, client_nsa, provider_nsa, connection_ids, global_ids)

    # some aggregate commands
    elif config.subCommand == 'resvprov':
        raise NotImplementedError('Reserve + provision aggregate command not implemented')

    else:
        print "No subcommand specified"
        print '%s: Try --help for usage details.' % (sys.argv[0])
        return

    # shutdown service
    yield iport.stopListening()


def main():

    def slightlyDelayedShutdown(_):
        # this means that the reactor/kernel will have a bit of time
        # to push off any replies/acks before shutdown
        reactor.callLater(0.1, reactor.stop)

    def printError(error):
        if error.type == SystemExit:
            return
        elif error.type == usage.UsageError:
            log.msg("Usage error: " + error.getErrorMessage())
        else:
            #print "Error: %s" % error.value
            log.err(error)

    d = defer.maybeDeferred(doMain)
    d.addErrback(printError)
    d.addBoth(slightlyDelayedShutdown)
    return d


if __name__ == '__main__':
    reactor.callWhenRunning(main)
    reactor.run()

